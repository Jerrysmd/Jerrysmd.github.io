<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sql on JerrysBlog</title>
    <link>https://Jerrysmd.github.io/tags/sql/</link>
    <description>Recent content in sql on JerrysBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 18 Nov 2018 21:58:51 -0800</lastBuildDate><atom:link href="https://Jerrysmd.github.io/tags/sql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SQLcipher Guide</title>
      <link>https://Jerrysmd.github.io/post/20181118sqlcipher/sqlcipher/</link>
      <pubDate>Sun, 18 Nov 2018 21:58:51 -0800</pubDate>
      
      <guid>https://Jerrysmd.github.io/post/20181118sqlcipher/sqlcipher/</guid>
      <description>
        
          &lt;p&gt;SQLCipher is based on SQLite, and thus, the majority of the accessible API is identical to the C/C++ interface for SQLite 3. However, SQLCipher does add a number of security specific extensions in the form of PRAGMAs, SQL Functions and C Functions.&lt;/p&gt;
&lt;h2 id=&#34;1-build-sqlcipher-from-source&#34;&gt;1. Build SQLcipher from source&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;$ git clone &lt;a href=&#34;https://github.com/sqlcipher/sqlcipher.git&#34;&gt;https://github.com/sqlcipher/sqlcipher.git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;$ cd sqlcipher&lt;/li&gt;
&lt;li&gt;$ ./configure &amp;ndash;enable-tempstore=yes CFLAGS=&amp;quot;-DSQLITE_HAS_CODEC -DSQLITE_TEMP_STORE=2&amp;quot; LDFLAGS=&amp;quot;-lcrypto&amp;quot;&lt;/li&gt;
&lt;li&gt;$ make&lt;/li&gt;
&lt;li&gt;$ make install &lt;em&gt;#if you want to do a system wide install of SQLCipher&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Mark the output of make install, especially the following lines:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;libtool: install: /usr/bin/install -c .libs/libsqlcipher.a /usr/local/lib/libsqlcipher.a&lt;/li&gt;
&lt;li&gt;/usr/bin/install -c -m 0644 sqlite3.h /usr/local/include/sqlcipher&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;these are the folders of SQLcipher headers and the library necessary when building proper C project.&lt;/p&gt;
&lt;h2 id=&#34;2-building-minimal-c-project-example&#34;&gt;2. Building minimal C project example&lt;/h2&gt;
&lt;p&gt;In SQLite_example.c put the following lines:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;sqlite3.h&amp;quot; //We want to SQLCipher extension, rather then a system wide SQLite header
rc = sqlite3_open(&amp;quot;test.db&amp;quot;,&amp;amp;db); //open SQLite database test.db
rc = sqlite3_key(db,&amp;quot;1q2w3e4r&amp;quot;,8); //apply encryption to previously opened database
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build you example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$gcc SQLite_example.c -o SQLtest -I /path/to/local/folder/with/sqlcipher/header/files/ -L /path/to/local/folder/with/sqlcipher/library.a -l sqlcipher
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;e.g. with paths extracted from the output of $make install&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$gcc SQLite_example.c -o SQLtest -I /usr/local/include/sqlcipher -L /usr/local/lib/libsqlcipher.a -lsqlcipher
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, make sure that your SQLCipher library is in the system wide library path e.g. for (Arch)Linux:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ export LD_LIBRARY_PATH=/usr/local/lib/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run your test code ((Arch)Linux):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./SQLtest
&lt;/code&gt;&lt;/pre&gt;
        
      </description>
    </item>
    
    <item>
      <title>SQL Introduction</title>
      <link>https://Jerrysmd.github.io/post/20181017sqlintroduction/sqlintroduction/</link>
      <pubDate>Wed, 17 Oct 2018 11:52:36 +0800</pubDate>
      
      <guid>https://Jerrysmd.github.io/post/20181017sqlintroduction/sqlintroduction/</guid>
      <description>
        
          &lt;p&gt;In computer programming, create, read, update, and delete (CRUD) are the four basic functions of persistent storage. Alternate words are sometimes used when defining the four basic functions of CRUD, such as retrieve instead of read, modify instead of update, or destroy instead of delete. CRUD is also sometimes used to describe user interface conventions that facilitate viewing, searching, and changing information, often using computer-based forms and reports.&lt;/p&gt;
&lt;h3 id=&#34;1-查询语句&#34;&gt;1. 查询语句&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;select &amp;hellip;&lt;/th&gt;
&lt;th&gt;from &amp;hellip;&lt;/th&gt;
&lt;th&gt;where &amp;hellip;&lt;/th&gt;
&lt;th&gt;group by &amp;hellip;&lt;/th&gt;
&lt;th&gt;having &amp;hellip;&lt;/th&gt;
&lt;th&gt;order by &amp;hellip;&lt;/th&gt;
&lt;th&gt;limit &amp;hellip;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;次序&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;2-group-by&#34;&gt;2. Group by&lt;/h3&gt;
&lt;p&gt;GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; SELECT * FROM access_log;
+-----+---------+-------+------------+
| aid | site_id | count | date       |
+-----+---------+-------+------------+
|   1 |       1 |    45 | 2016-05-10 |
|   2 |       3 |   100 | 2016-05-13 |
|   3 |       1 |   230 | 2016-05-14 |
|   4 |       2 |    10 | 2016-05-14 |
|   5 |       5 |   205 | 2016-05-14 |
|   6 |       4 |    13 | 2016-05-15 |
|   7 |       3 |   220 | 2016-05-15 |
|   8 |       5 |   545 | 2016-05-16 |
|   9 |       3 |   201 | 2016-05-17 |
+-----+---------+-------+------------+
9 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT site_id, SUM(access_log.count) AS nums
FROM access_log GROUP BY site_id;
+---------+------+
| site_id | nums |
+---------+------+
|   1     |  275 |
|   2     |   10 |
|   3     |  521 |
|   4     |   13 |
|   5     |  750 |
+---------+------+

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-聚集函数&#34;&gt;3. 聚集函数&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;count&lt;/td&gt;
&lt;td&gt;sum&lt;/td&gt;
&lt;td&gt;max&lt;/td&gt;
&lt;td&gt;min&lt;/td&gt;
&lt;td&gt;avg&lt;/td&gt;
&lt;td&gt;group_concat&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-having&#34;&gt;4. Having&lt;/h3&gt;
&lt;p&gt;HAVING 子句可以让我们筛选分组后的各组数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;查询每个班中人数大于2的班级号：
select count(1) as n, classid from stu group by classid having n&amp;gt;2;
or
select classid from stu group by classid having count(1)&amp;gt;2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-order-by&#34;&gt;5. Order by&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;... order by n, classid;
1.先按n排序
2.在不改n排序的情况下排classid
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-limit&#34;&gt;6. Limit&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;... limit 1, 10;
# 检索记录行 2-10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-join&#34;&gt;7. Join&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;stu join class on classid = class.id
# join 会把左表的每一行分别与右表每一行拼接
# on 做筛选
&lt;/code&gt;&lt;/pre&gt;
        
      </description>
    </item>
    
  </channel>
</rss>
