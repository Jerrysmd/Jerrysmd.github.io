<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>file on JerrysBlog</title>
    <link>https://Jerrysmd.github.io/tags/file/</link>
    <description>Recent content in file on JerrysBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 20 Dec 2018 18:39:37 -0700</lastBuildDate><atom:link href="https://Jerrysmd.github.io/tags/file/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>文件读取的高级方法：Advanced method of reading files</title>
      <link>https://Jerrysmd.github.io/post/20181220read_binary_file/read_binary_file/</link>
      <pubDate>Thu, 20 Dec 2018 18:39:37 -0700</pubDate>
      
      <guid>https://Jerrysmd.github.io/post/20181220read_binary_file/read_binary_file/</guid>
      <description>
        
          &lt;p&gt;读取二进制文件（任何文件都可以，本文以二进制为例），把二进制文件内容全部读取到char*字符串中。配合fseek()和fread()函数实现文件读取的高级方法。&lt;/p&gt;
&lt;h1 id=&#34;需求&#34;&gt;需求&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;使用fwrite(dbdata, dblength, 1,fp)把字节流写入二进制文件。在新程序读取二进制文件遇到问题：二进制内容不能向文本一样行读取，也不知道二进制文件长度，在fread()函数中无从下手。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1creat-file-pointer-and-set-mode-as-rb&#34;&gt;1.creat FILE pointer and set mode as &amp;lsquo;rb&amp;rsquo;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;FILE *f = fopen(inputFN, &amp;quot;rb&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2check-the-file-pointer-is-not-null&#34;&gt;2.check the FILE pointer is not null&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (!f) {
        fprintf(stderr, &amp;quot;ERROR: unable to open file \&amp;quot;%s\&amp;quot;: %s\n&amp;quot;, inputFN,strerror(errno));
        return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3use-fseekftell-to-get-data-length&#34;&gt;3.use fseek/ftell to get data length&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;fseek(f,0,SEEK_END) put the pointer to the end of the file.&lt;/li&gt;
&lt;li&gt;ftell(f) can get the current offset.&lt;/li&gt;
&lt;li&gt;then use fseek(f,0,SEEK_SET) put the pointer to the start of file.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (fseek(f, 0, SEEK_END) != 0) {
        fprintf(stderr, &amp;quot;ERROR: unable to seek file \&amp;quot;%s\&amp;quot;: %s\n&amp;quot;, inputFN,
                strerror(errno));
        fclose(f);
        return NULL;
}
long datalen = ftell(f);
if (dataLen &amp;lt; 0) {
        fprintf(stderr, &amp;quot;ERROR: ftell() failed: %s\n&amp;quot;, strerror(errno));
        fclose(f);
        return NULL;
}
    if (fseek(f, 0, SEEK_SET) != 0) {
        fprintf(stderr, &amp;quot;ERROR: unable to seek file \&amp;quot;%s\&amp;quot;: %s\n&amp;quot;, inputFN,
                strerror(errno));
        fclose(f);
        return NULL;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4check-the-datalen&#34;&gt;4.check the datalen&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if ((unsigned long)dataLen &amp;gt; UINT_MAX) {
        dataLen = UINT_MAX;
        printf(&amp;quot;WARNING: clipping data to %ld bytes\n&amp;quot;, dataLen);
    } else if (dataLen == 0) {
        fprintf(stderr, &amp;quot;ERROR: input file \&amp;quot;%s\&amp;quot; is empty\n&amp;quot;, inputFN);
        fclose(f);
        return NULL;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5malloc-memory-to-char-inputdata&#34;&gt;5.malloc memory to char *inputData&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char *inputData = static_cast&amp;lt;char *&amp;gt;(malloc(dataLen));
    if (!inputData) {
        fprintf(stderr, &amp;quot;ERROR: unable to malloc %ld bytes\n&amp;quot;, dataLen);
        fclose(f);
        return NULL;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6read-the-bin-data&#34;&gt;6.read the bin data&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// create a pointer p to point the begin of the inputData
char *p = inputData;
// create a bytesLeft to record the moving of offset
size_t bytesLeft = dataLen;
while (bytesLeft) {
	//fread will return the bytes of read
        size_t bytesRead = fread(p, 1, bytesLeft, f);
        bytesLeft -= bytesRead;
        p += bytesRead;
        if (ferror(f) != 0) {
            fprintf(stderr, &amp;quot;ERROR: fread() failed\n&amp;quot;);
            free(inputData);
            fclose(f);
            return NULL;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7close-the-file-stream&#34;&gt;7.close the File stream&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;fclose(f);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8return-length--inputdata&#34;&gt;8.return length &amp;amp; inputData&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//change the parameter of &amp;amp;length
*length = (unsigned int)dataLen;
return inputData;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9完整代码&#34;&gt;9.完整代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    FILE *f = fopen(inputFN, &amp;quot;rb&amp;quot;);
    if (!f) {
        fprintf(stderr, &amp;quot;ERROR: unable to open file \&amp;quot;%s\&amp;quot;: %s\n&amp;quot;, inputFN,strerror(errno));
        return NULL;
    }

    if (fseek(f, 0, SEEK_END) != 0) {
        fprintf(stderr, &amp;quot;ERROR: unable to seek file \&amp;quot;%s\&amp;quot;: %s\n&amp;quot;, inputFN,
                strerror(errno));
        fclose(f);
        return NULL;
    }
    long dataLen = ftell(f);
    if (dataLen &amp;lt; 0) {
        fprintf(stderr, &amp;quot;ERROR: ftell() failed: %s\n&amp;quot;, strerror(errno));
        fclose(f);
        return NULL;
    }
    if (fseek(f, 0, SEEK_SET) != 0) {
        fprintf(stderr, &amp;quot;ERROR: unable to seek file \&amp;quot;%s\&amp;quot;: %s\n&amp;quot;, inputFN,
                strerror(errno));
        fclose(f);
        return NULL;
    }

    if ((unsigned long)dataLen &amp;gt; UINT_MAX) {
        dataLen = UINT_MAX;
        printf(&amp;quot;WARNING: clipping data to %ld bytes\n&amp;quot;, dataLen);
    } else if (dataLen == 0) {
        fprintf(stderr, &amp;quot;ERROR: input file \&amp;quot;%s\&amp;quot; is empty\n&amp;quot;, inputFN);
        fclose(f);
        return NULL;
    }

    char *inputData = static_cast&amp;lt;char *&amp;gt;(malloc(dataLen));
    if (!inputData) {
        fprintf(stderr, &amp;quot;ERROR: unable to malloc %ld bytes\n&amp;quot;, dataLen);
        fclose(f);
        return NULL;
    }

    char *p = inputData;
    size_t bytesLeft = dataLen;
    while (bytesLeft) {
        size_t bytesRead = fread(p, 1, bytesLeft, f);
        bytesLeft -= bytesRead;
        p += bytesRead;
        if (ferror(f) != 0) {
            fprintf(stderr, &amp;quot;ERROR: fread() failed\n&amp;quot;);
            free(inputData);
            fclose(f);
            return NULL;
        }
    }

    fclose(f);

    *length = (unsigned int)dataLen;
&lt;/code&gt;&lt;/pre&gt;
        
      </description>
    </item>
    
    <item>
      <title>文件读取多读取一行空行问题: The problem about file reading one more line</title>
      <link>https://Jerrysmd.github.io/post/20180610cgetline/cgetline/</link>
      <pubDate>Sun, 10 Jun 2018 21:58:13 -0800</pubDate>
      
      <guid>https://Jerrysmd.github.io/post/20180610cgetline/cgetline/</guid>
      <description>
        
          &lt;p&gt;getline()/get()/read()会出现多读一行的现象。造成该原因可能文件本身问题和getline()函数的问题。可以在while处判断时先判断getline()/get()/read()，如果拿到数据再处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Insert Lead paragraph here.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-问题原因&#34;&gt;1. 问题原因&lt;/h2&gt;
&lt;h3 id=&#34;1-问题1-文件末尾存在回车&#34;&gt;1. 问题1: 文件末尾存在回车&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;　　while (!feof(fp))
　　{
　　	fgets(buffer,256,fp);
　　	j++;
　　}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;feof（）这个函数是用来判断指针是否已经到达文件尾部的。若fp已经指向文件末尾，则feof（fp）函数值为“真”，即返回非零值；否则返回0。&lt;/p&gt;
&lt;p&gt;如果文件还有换行或者空格的时候， 他会继续循环。&lt;/p&gt;
&lt;h3 id=&#34;2问题2-getlines1024n函数&#34;&gt;2.问题2: getline(s,1024,&#39;\n&#39;)函数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;　　while(!feof(s))
　　{
    　　infile.getline(s,1024,&#39;\n&#39;);
　　}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后语句&lt;mark&gt;infile.getline(s,1024,&#39;\n&#39;)&lt;/mark&gt;未读到内容，出错后，变量s的内容并没改变，程序仍可继续执行，使s中的原数据再使用了一次。&lt;/p&gt;
&lt;h2 id=&#34;2-解决方法&#34;&gt;2. 解决方法&lt;/h2&gt;
&lt;h3 id=&#34;1-fgets放到while里判断&#34;&gt;1. fgets放到while里判断&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;　　while (fgets(buffer,256,fp))
　　{
　　	j++;
　　}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2getline放到while里判断&#34;&gt;2.getline放到while里判断&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;　　while(infile.getline(s,1024,&#39;\n&#39;))
　　{
　　　　.......
　　}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即infile.getline(s,1024,&#39;\n&#39;)正确读到数据后再处理。&lt;/p&gt;
&lt;p&gt;同理，对get()/read()等都类似处理。&lt;/p&gt;
        
      </description>
    </item>
    
  </channel>
</rss>
