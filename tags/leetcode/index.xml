<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on JerrysBlog</title>
    <link>https://Jerrysmd.github.io/tags/leetcode/</link>
    <description>Recent content in leetcode on JerrysBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 01 Jan 2020 10:57:11 +0800</lastBuildDate><atom:link href="https://Jerrysmd.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Algorithm</title>
      <link>https://Jerrysmd.github.io/post/20200101leetcode/leetcode/</link>
      <pubDate>Wed, 01 Jan 2020 10:57:11 +0800</pubDate>
      
      <guid>https://Jerrysmd.github.io/post/20200101leetcode/leetcode/</guid>
      <description>
        
          &lt;p&gt;Algorithms are used in every part of computer science. They form the field&amp;rsquo;s backbone. In computer science, an algorithm gives the computer a specific set of instructions, which allows the computer to do everything, be it running a calculator or running a rocket.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异或运算&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与自己异或等于0，与0异或等于自己&lt;/li&gt;
&lt;li&gt;遵循交换律和结合律&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//1.两数交换：
arr[i] = arr[i] ^ arr[j]; // a = a ^ b
arr[j] = arr[i] ^ arr[j]; // b = (a ^ b) ^ b = a
arr[i] = arr[i] ^ arr[j]; // a = (a ^ b) ^ a = b
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//2.数组中有一个出现奇数次的数
int eor = 0;
for(int cur : arr){
    eor ^= cur; //[a,a,b,b,c,c,c]  =&amp;gt; a^a^b^b^c^c^c = c
}
System.out.println(eor);

//3.数组中有两个出现奇数次的数
int eor = 0;
for(int cur : arr){
    eor ^= cur; //[a,a,b,b,b,c,c,c]  =&amp;gt; a^a^b^b^b^c^c^c = b^c
}
//eor = b ^ c
//eor != 0
//eor必然有个一位置上是1, 说明这个位置上b和c不同
int rightOne = eor &amp;amp; (~eor + 1);  //（取反 + 1） &amp;amp; 自己 = 提取出只保留最右侧的1

int result1 = 0;
for(int cur : arr){
    if((cur &amp;amp; rightOne) == 0){ //已知在rightOne这个位置上b和c不同，通过(&amp;amp; rightOne)把b和c区分开,别的数是偶数个，异或起来是0不同管
        result1 ^= cur; //这样result1是b或者c
    }
}
int result2 = eor ^ result1;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;插入排序&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念： 将后部分的数据(从第二开始)按照一定的顺序一个一个的插入到前部分有序的表中&lt;/li&gt;
&lt;li&gt;时间复杂度：O(N^2)&lt;/li&gt;
&lt;li&gt;额外空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;数据状况不同，时间复杂度不同:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度是按照&lt;strong&gt;最差情况&lt;/strong&gt;考虑&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void insertionSort(int[] arr) {
    if (arr == null || arr.length &amp;lt; 2){
        return;
    }
    for (int i = 1; i &amp;lt; arr.length; i++){
        for(int j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; arr[j] &amp;gt; arr[j+1]; j--){
            swap(arr, j, j+1);
        }
    }
}
public static void swap(int[] arr, int i, int j){
    arr[i] = arr[i] ^ arr[j]; 
	arr[j] = arr[i] ^ arr[j]; 
	arr[i] = arr[i] ^ arr[j];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;二分查找&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(logN)  (logN默认指log以2为底)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;例题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在一个有序数组中，找某个数是否存在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在一个有序数组中，找 &amp;gt;= 某个数最左侧的位置：二分查找直到左侧没有数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无序，相邻数一定不相等，找一个局部最小(i-1 &amp;lt; i &amp;lt; i+1)的数，复杂度能否好于O(N)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;先判断首尾项是否满足要求，若首尾项不满足要求，一定是\进/出，中间一定有低谷拐点。
然后判断中间点是否满足要求，若不满足，分为两种情况：
1. 斜坡，则一方可与起点或终点组成\进/出。
2. 顶峰，则两方向都满足\进/出条件，两个方向都可继续进行二分法
直到判断出某个二分法中点满足要求。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;求中间数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mid = (L + R) / 2                 // L + R 可能会越界，这时mid算出负数&lt;/li&gt;
&lt;li&gt;mid = L + (R - L) / 2&lt;/li&gt;
&lt;li&gt;mid = L + (R - L) &amp;raquo; 1        //右移一位比除2快&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对数器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结果对比校验器: 自己控制输入数据，使用两种方法或和官方api对比结果&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;(int)(Math.random() * N) //会在[0, N-1]范围内，等概率返回一个整数

int[] arr = new int[(int)((maxSize + 1) * Math.random())];//随机长度
for (int i = 0; i &amp;lt; arr.length; i++){
    arr[i] = (int)((maxValue + 1) * Math.random()) - (int)(maxValue * Math.random());
}
return arr;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int getMax(int[] arr){
    return process(arr, 0, arr.length - 1);
}

public static int process(int[] arr, int L, int R){
    if(L == R){
        return arr[L];
    }
    int mid = L + ((R - L) &amp;gt;&amp;gt; 1);
    int leftMax = process(arr, L, mid);
    int rightMax = process(arr, mid + 1, R);
    return Math.max(leftMax, rightMax);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;递归时间复杂度估算&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Master公式： T(N) = a * T (N / b) + 0 (N ^ d)
&lt;ol&gt;
&lt;li&gt;log(b, a) &amp;gt; d,	则复杂度为O(N ^ log(b, a))&lt;/li&gt;
&lt;li&gt;log(b, a) = d,	则复杂度为O(N ^ d * logN)&lt;/li&gt;
&lt;li&gt;log(b, a) &amp;lt; d,	则复杂度为O(N ^ d)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;归并排序&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念：将n个元素分成个含n/2个元素的子序列，用合并排序法对两个子序列递归的排序，合并两个已排序的子序列已得到排序结果。&lt;/li&gt;
&lt;li&gt;时间复杂度：使用Master公式： T(N) = 2a +&lt;/li&gt;
&lt;li&gt;代码实现：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void process(int[] arr, int L, int R){
    if(L == R){
        return;
    }
    int mid = L + ((R - L) &amp;gt;&amp;gt; 1);
    process(arr, L, mid);
    process(arr, mid + 1, R);
    merge(arr, L, mid, R);
}

public static void merge(int[] arr, int L, int mid, int R){
    int[] extr = new int[R - L + 1];
    int extri = 0;
    int p1 = L;
    int p2 = M + 1;
    while(p1 &amp;lt;= M &amp;amp;&amp;amp; p2 &amp;lt;= R){
        extr[i++] = arr[p1] &amp;lt;= arr[p2] ? arr[p1++]: arr[p2++];
    }
    while(p1 &amp;lt;= M){
        extr[i++] = arr[p1++];
    }
    while(p2 &amp;lt;= R){
        extr[i++] = arr[p2++];
    }
    for(i = 0; i &amp;lt; extra.length; i++){
        arr[L + i] = extra[i];
    }
}
&lt;/code&gt;&lt;/pre&gt;
        
      </description>
    </item>
    
  </channel>
</rss>
