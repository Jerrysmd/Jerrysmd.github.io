<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hash on JerrysBlog</title>
    <link>https://Jerrysmd.github.io/tags/hash/</link>
    <description>Recent content in hash on JerrysBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 05 Apr 2018 21:56:51 -0800</lastBuildDate><atom:link href="https://Jerrysmd.github.io/tags/hash/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C语言实现HashMap: C language realize HashMap</title>
      <link>https://Jerrysmd.github.io/post/20180405hashcode/hashcode/</link>
      <pubDate>Thu, 05 Apr 2018 21:56:51 -0800</pubDate>
      
      <guid>https://Jerrysmd.github.io/post/20180405hashcode/hashcode/</guid>
      <description>
        
          &lt;p&gt;哈希表是一种十分重要的数据结构，在很多应用场景下都有用到，本文会对哈希表原理进行简单的剖析，并使用C语言实现一个完整的HashMap。&lt;/p&gt;
&lt;h2 id=&#34;1-什么是hashmap&#34;&gt;1. 什么是HashMap？&lt;/h2&gt;
&lt;p&gt;存储方式主要有两种&lt;code&gt;线性存储&lt;/code&gt;和&lt;code&gt;链式存储&lt;/code&gt;，常见的线性存储例如数组，常见的链式存储如链表、二叉树等。哈希表的存储主干为线性存储，这也是它在理想状态(无冲突)下时间复杂度为&lt;code&gt;O(1)&lt;/code&gt;的关键所在。普通线性存储的存储内容与索引地址之间没有任何的联系，只能通过索引地址推算出存储内容，不能从存储内容推算出索引地址，是一个&lt;mark&gt;单向不可逆&lt;/mark&gt;的过程，而HashMap存储的是一个&lt;mark&gt;&amp;lt;key, value&amp;gt;&lt;/mark&gt;的键值对，通过key和索引地址建立了一层关系，这层关系称之为哈希函数(或散列函数)，这样既可以通过key推算出索引地址，也可以通过推算出的索引地址直接定位到键值对，这是一个&lt;mark&gt;双向可逆&lt;/mark&gt;的过程。需要注意的一点是HashMap并不直接暴露出键值对的索引地址，但是可以通过哈希函数推算出&lt;code&gt;HashCode&lt;/code&gt;，其实HashCode就是真实的索引地址。&lt;/p&gt;
&lt;h2 id=&#34;2-定义键值对结构&#34;&gt;2. 定义键值对结构&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct entry {
    void * key;             // 键
    void * value;           // 值
    struct entry * next;    // 冲突链表
}*Entry;

#define newEntry() NEW(struct entry)
#define newEntryList(length) (Entry)malloc(length * sizeof(struct entry))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;哈希冲突是指两个不同的key值得到了一个相同的HashCode，这种情况称之为&lt;mark&gt;哈希冲突&lt;/mark&gt;，一个好的哈希函数很大程度上决定了哈希表的性能，不存在一种适合所有哈希表的哈希函数，在很多特定的情景下，需要有针对性的设计哈希函数才能达到理想的效果。当然啦，还是有一些优秀的哈希函数可以应对大多数情况的，对于性能要求不是很高的场景用这些就可以了。使用HashMap的时候难免会发生冲突，常用的方法主要分为两类：&lt;code&gt;再散列法&lt;/code&gt;和&lt;code&gt;链地址法&lt;/code&gt;。再散列法就是发生冲突时使用另一个哈希函数重新推算，一直到不冲突为止，这种方法有时候会造成数据堆积，就是元素本来的HashCode被其它元素再散列的HashCode占用，被迫再散列，如此恶性循环。链地址法就是在冲突的位置建立一个链表，将冲突值放在链表中，检索的时候需要额外的遍历冲突链表，本文采用的就是链地址法。&lt;/p&gt;
&lt;h2 id=&#34;3-定义hashmap结构体&#34;&gt;3. 定义HashMap结构体&lt;/h2&gt;
&lt;p&gt;HashMap结构的存储本体是一个数组，建立一个&lt;mark&gt;Entry数组&lt;/mark&gt;作为存储空间，然后根据传入的key计算出HashCode，当做数组的索引存入数据，读取的时候通过计算出的HashCode可以在数组中直接取出值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size&lt;/code&gt;是当前存储键值对的数量，而&lt;code&gt;listSize&lt;/code&gt;是当前数组的大小，仔细观察键值对结构会发现，数组的每一项其实都是冲突链表的头节点。因为冲突的存在，就有可能导致size大于listSize，当size大于listSize的时候一定发生了冲突，这时候就会扩容。&lt;/p&gt;
&lt;p&gt;在结构体中放了一些常用的方法，因为C语言本身并没有类的概念，为了便于内部封装(经常会有一个方法调用另一个方法的时候)，可以让用户自定义一个方法而不影响其它方法的调用。举个简单的例子，put方法中调用了hashCode函数，如果想自定义一个hashCode方法，迫不得已还要再实现一个put方法，哪怕put中只改了一行代码。&lt;/p&gt;
&lt;p&gt;结构体定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 哈希结构
typedef struct hashMap *HashMap;
#define newHashMap() NEW(struct hashMap)

// 哈希函数类型
typedef int(*HashCode)(HashMap, void * key);

// 判等函数类型
typedef Boolean(*Equal)(void * key1, void * key2);

// 添加键函数类型
typedef void(*Put)(HashMap hashMap, void * key, void * value);

// 获取键对应值的函数类型
typedef void * (*Get)(HashMap hashMap, void * key);

// 删除键的函数类型
typedef Boolean(*Remove)(HashMap hashMap, void * key);

// 清空Map的函数类型
typedef void(*Clear)(HashMap hashMap);

// 判断键值是否存在的函数类型
typedef Boolean(*Exists)(HashMap hashMap, void * key);

typedef struct hashMap {
    int size;           // 当前大小
    int listSize;       // 有效空间大小
    HashCode hashCode;  // 哈希函数
    Equal equal;        // 判等函数
    Entry list;         // 存储区域
    Put put;            // 添加键的函数
    Get get;            // 获取键对应值的函数
    Remove remove;      // 删除键
    Clear clear;        // 清空Map
    Exists exists;      // 判断键是否存在
    Boolean autoAssign;	// 设定是否根据当前数据量动态调整内存大小，默认开启
}*HashMap;

// 默认哈希函数
static int defaultHashCode(HashMap hashMap, void * key);

// 默认判断键值是否相等
static Boolean defaultEqual(void * key1, void * key2);

// 默认添加键值对
static void defaultPut(HashMap hashMap, void * key, void * value);

// 默认获取键对应值
static void * defaultGet(HashMap hashMap, void * key);

// 默认删除键
static Boolean defaultRemove(HashMap hashMap, void * key);

// 默认判断键是否存在
static Boolean defaultExists(HashMap hashMap, void * key);

// 默认清空Map
static void defaultClear(HashMap hashMap);

// 创建一个哈希结构
HashMap createHashMap(HashCode hashCode, Equal equal);

// 重新构建
static void resetHashMap(HashMap hashMap, int listSize);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HashMap的所有属性方法都有一个默认的实现，创建HashMap时可以指定哈希函数和判等函数(用于比较两个key是否相等)，传入NULL时将使用默认函数。这些函数都被设置为了static，在文件外不可访问。&lt;/p&gt;
&lt;h2 id=&#34;4-哈希函数&#34;&gt;4. 哈希函数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int defaultHashCode(HashMap hashMap, let key)
{
    IN_STACK;
    string k = (string)key;
    unsigned long h = 0;
    while (*k) {
        h = (h &amp;lt;&amp;lt; 4) + *k++;
        unsigned long g = h &amp;amp; 0xF0000000L;
        if (g) {
            h ^= g &amp;gt;&amp;gt; 24;
        }
        h &amp;amp;= ~g;
    }
    OUT_STACK;
    return h % hashMap-&amp;gt;listSize;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;key的类型为void *，是一个任意类型，HashMap本身也没有规定key值一定是string类型，上面的哈希函数只针对string类型，可以根据实际需要替换成其他。&lt;/p&gt;
&lt;h2 id=&#34;5-put函数&#34;&gt;5. put函数&lt;/h2&gt;
&lt;p&gt;用于在哈希表中存入一个键值对，首先先推算出HashCode，然后判断该地址是否已经有数据，如果已有的key值和存入的key值相同，改变value即可，否则为冲突，需要挂到冲突链尾部，该地址没有数据时直接存储。实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void resetHashMap(HashMap hashMap, int listSize) {

    if (listSize &amp;lt; 8) return;

    // 键值对临时存储空间
    Entry tempList = newEntryList(hashMap-&amp;gt;size);

    HashMapIterator iterator = createHashMapIterator(hashMap);
    int length = hashMap-&amp;gt;size;
    for (int index = 0; hasNextHashMapIterator(iterator); index++) {
        // 迭代取出所有键值对
        iterator = nextHashMapIterator(iterator);
        tempList[index].key = iterator-&amp;gt;entry-&amp;gt;key;
        tempList[index].value = iterator-&amp;gt;entry-&amp;gt;value;
        tempList[index].next = NULL;
    }
    freeHashMapIterator(&amp;amp;iterator);

    // 清除原有键值对数据
    hashMap-&amp;gt;size = 0;
    for (int i = 0; i &amp;lt; hashMap-&amp;gt;listSize; i++) {
        Entry current = &amp;amp;hashMap-&amp;gt;list[i];
        current-&amp;gt;key = NULL;
        current-&amp;gt;value = NULL;
        if (current-&amp;gt;next != NULL) {
            while (current-&amp;gt;next != NULL) {
                Entry temp = current-&amp;gt;next-&amp;gt;next;
                free(current-&amp;gt;next);
                current-&amp;gt;next = temp;
            }
        }
    }

    // 更改内存大小
    hashMap-&amp;gt;listSize = listSize;
    Entry relist = (Entry)realloc(hashMap-&amp;gt;list, hashMap-&amp;gt;listSize * sizeof(struct entry));
    if (relist != NULL) {
        hashMap-&amp;gt;list = relist;
        relist = NULL;
    }

    // 初始化数据
    for (int i = 0; i &amp;lt; hashMap-&amp;gt;listSize; i++) {
        hashMap-&amp;gt;list[i].key = NULL;
        hashMap-&amp;gt;list[i].value = NULL;
        hashMap-&amp;gt;list[i].next = NULL;
    }

    // 将所有键值对重新写入内存
    for (int i = 0; i &amp;lt; length; i++) {
        Array x = tempList[i].value;
        hashMap-&amp;gt;put(hashMap, tempList[i].key, tempList[i].value);
    }
    free(tempList);
}

void defaultPut(HashMap hashMap, let key, let value) {
    if (hashMap-&amp;gt;autoAssign &amp;amp;&amp;amp; hashMap-&amp;gt;size &amp;gt;= hashMap-&amp;gt;listSize) {

        // 内存扩充至原来的两倍
        // *注: 扩充时考虑的是当前存储元素数量与存储空间的大小关系，而不是存储空间是否已经存满，
        // 例如: 存储空间为10，存入了10个键值对，但是全部冲突了，所以存储空间空着9个，其余的全部挂在一个上面，
        // 这样检索的时候和遍历查询没有什么区别了，可以简单这样理解，当我存入第11个键值对的时候一定会发生冲突，
        // 这是由哈希函数本身的特性(取模)决定的，冲突就会导致检索变慢，所以这时候扩充存储空间，对原有键值对进行
        // 再次散列，会把冲突的数据再次分散开，加快索引定位速度。
        resetHashMap(hashMap, hashMap-&amp;gt;listSize * 2);
    }

    int index = hashMap-&amp;gt;hashCode(hashMap, key);
    if (hashMap-&amp;gt;list[index].key == NULL) {
        hashMap-&amp;gt;size++;
        // 该地址为空时直接存储
        Array x = value;
        hashMap-&amp;gt;list[index].key = key;
        hashMap-&amp;gt;list[index].value = value;
    }
    else {

        Entry current = &amp;amp;hashMap-&amp;gt;list[index];
        while (current != NULL) {
            if (hashMap-&amp;gt;equal(key, current-&amp;gt;key)) {
                // 对于键值已经存在的直接覆盖
                current-&amp;gt;value = value;
                return;
            }
            current = current-&amp;gt;next;
        };

        // 发生冲突则创建节点挂到相应位置的next上
        Entry entry = newEntry();
        entry-&amp;gt;key = key;
        entry-&amp;gt;value = value;
        entry-&amp;gt;next = hashMap-&amp;gt;list[index].next;
        hashMap-&amp;gt;list[index].next = entry;
        hashMap-&amp;gt;size++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;put函数还有一个重要的功能，当size大于listSize时要主动扩容，这个判定条件看似有些不合理，当size大于listSize的时候可能因为冲突的存在，数组并没有存满，这时候就扩容不是浪费存储空间吗？事实确实如此，但这其实是为了加快检索速度一种妥协的办法，上文提到过，当size大于listSize时一定会发生冲突，因为哈希函数为了不越界，都会将计算出的HashCode进行取余操作，这就导致HashCode的个数一共就listSize个，超过这个个数就一定会冲突，冲突的越多，检索速度就越向O(n)靠拢，为了保证索引速度消耗一定的空间还是比较划算的，扩容时直接将容量变为了当前的两倍，这是考虑到扩容时需要将所有重新计算所有元素的HashCode，较为消耗时间，所以应该尽量的减少扩容次数。&lt;/p&gt;
&lt;h2 id=&#34;6-其它函数&#34;&gt;6. 其它函数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;let defaultGet(HashMap hashMap, let key) {
    int index = hashMap-&amp;gt;hashCode(hashMap, key);
    Entry entry = &amp;amp;hashMap-&amp;gt;list[index];
    while (entry-&amp;gt;key != NULL &amp;amp;&amp;amp; !hashMap-&amp;gt;equal(entry-&amp;gt;key, key)) {
        entry = entry-&amp;gt;next;
    }
    return entry-&amp;gt;value;
}

Boolean defaultRemove(HashMap hashMap, let key) {
    int index = hashMap-&amp;gt;hashCode(hashMap, key);
    Entry entry = &amp;amp;hashMap-&amp;gt;list[index];
    if (entry-&amp;gt;key == NULL) {
        return False;
    }
    Boolean result = False;
    if (hashMap-&amp;gt;equal(entry-&amp;gt;key, key)) {
        hashMap-&amp;gt;size--;
        if (entry-&amp;gt;next != NULL) {
            Entry temp = entry-&amp;gt;next;
            entry-&amp;gt;key = temp-&amp;gt;key;
            entry-&amp;gt;value = temp-&amp;gt;value;
            entry-&amp;gt;next = temp-&amp;gt;next;
            free(temp);
        }
        else {
            entry-&amp;gt;key = entry-&amp;gt;value = NULL;
        }
        result = True;
    }
    else {
        Entry p = entry;
        entry = entry-&amp;gt;next;
        while (entry != NULL) {
            if (hashMap-&amp;gt;equal(entry-&amp;gt;key, key)) {
                hashMap-&amp;gt;size--;
                p-&amp;gt;next = entry-&amp;gt;next;
                free(entry);
                result = True;
                break;
            }
            p = entry;
            entry = entry-&amp;gt;next;
        };
    }

    // 如果空间占用不足一半，则释放多余内存
    if (result &amp;amp;&amp;amp; hashMap-&amp;gt;autoAssign &amp;amp;&amp;amp;  hashMap-&amp;gt;size &amp;lt; hashMap-&amp;gt;listSize / 2) {
        resetHashMap(hashMap, hashMap-&amp;gt;listSize / 2);
    }
    return result;
}

Boolean defaultExists(HashMap hashMap, let key) {
    int index = hashMap-&amp;gt;hashCode(hashMap, key);
    Entry entry = &amp;amp;hashMap-&amp;gt;list[index];
    if (entry-&amp;gt;key == NULL) {
        return False;
    }
    if (hashMap-&amp;gt;equal(entry-&amp;gt;key, key)) {
        return True;
    }
    if (entry-&amp;gt;next != NULL) {
        do {
            if (hashMap-&amp;gt;equal(entry-&amp;gt;key, key)) {
                return True;
            }
            entry = entry-&amp;gt;next;

        } while (entry != NULL);
        return False;
    }
    else {
        return False;
    }
}

void defaultClear(HashMap hashMap) {
    for (int i = 0; i &amp;lt; hashMap-&amp;gt;listSize; i++) {
        // 释放冲突值内存
        Entry entry = hashMap-&amp;gt;list[i].next;
        while (entry != NULL) {
            Entry next = entry-&amp;gt;next;
            free(entry);
            entry = next;
        }
        hashMap-&amp;gt;list[i].next = NULL;
    }
    // 释放存储空间
    free(hashMap-&amp;gt;list);
    hashMap-&amp;gt;list = NULL;
    hashMap-&amp;gt;size = -1;
    hashMap-&amp;gt;listSize = 0;
}

HashMap createHashMap(HashCode hashCode, Equal equal) {
    HashMap hashMap = newHashMap();
    hashMap-&amp;gt;size = 0;
    hashMap-&amp;gt;listSize = 8;
    hashMap-&amp;gt;hashCode = hashCode == NULL ? defaultHashCode : hashCode;
    hashMap-&amp;gt;equal = equal == NULL ? defaultEqual : equal;
    hashMap-&amp;gt;exists = defaultExists;
    hashMap-&amp;gt;get = defaultGet;
    hashMap-&amp;gt;put = defaultPut;
    hashMap-&amp;gt;remove = defaultRemove;
    hashMap-&amp;gt;clear = defaultClear;
    hashMap-&amp;gt;autoAssign = True; 
    // 起始分配8个内存空间，溢出时会自动扩充
    hashMap-&amp;gt;list = newEntryList(hashMap-&amp;gt;listSize);
    Entry p = hashMap-&amp;gt;list;
    for (int i = 0; i &amp;lt; hashMap-&amp;gt;listSize; i++) {
        p[i].key = p[i].value = p[i].next = NULL;
    }
    return hashMap;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-iterator接口&#34;&gt;7. Iterator接口&lt;/h2&gt;
&lt;p&gt;Iterator接口提供了遍历HashMap结构的方法，基本定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 迭代器结构
typedef struct hashMapIterator {
    Entry entry;    // 迭代器当前指向
    int count;      // 迭代次数
    int hashCode;   // 键值对的哈希值
    HashMap hashMap;
}*HashMapIterator;

#define newHashMapIterator() NEW(struct hashMapIterator)

// 创建一个哈希结构
HashMap createHashMap(HashCode hashCode, Equal equal);

// 创建哈希结构迭代器
HashMapIterator createHashMapIterator(HashMap hashMap);

// 迭代器是否有下一个
Boolean hasNextHashMapIterator(HashMapIterator iterator);

// 迭代到下一次
HashMapIterator nextHashMapIterator(HashMapIterator iterator);

// 释放迭代器内存
void freeHashMapIterator(HashMapIterator * iterator);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;HashMapIterator createHashMapIterator(HashMap hashMap) {
    HashMapIterator iterator = newHashMapIterator();
    iterator-&amp;gt;hashMap = hashMap;
    iterator-&amp;gt;count = 0;
    iterator-&amp;gt;hashCode = -1;
    iterator-&amp;gt;entry = NULL;
    return iterator;
}

Boolean hasNextHashMapIterator(HashMapIterator iterator) {
    return iterator-&amp;gt;count &amp;lt; iterator-&amp;gt;hashMap-&amp;gt;size ? True : False;
}

HashMapIterator nextHashMapIterator(HashMapIterator iterator) {
    if (hasNextHashMapIterator(iterator)) {
        if (iterator-&amp;gt;entry != NULL &amp;amp;&amp;amp; iterator-&amp;gt;entry-&amp;gt;next != NULL) {
            iterator-&amp;gt;count++;
            iterator-&amp;gt;entry = iterator-&amp;gt;entry-&amp;gt;next;
            return iterator;
        }
        while (++iterator-&amp;gt;hashCode &amp;lt; iterator-&amp;gt;hashMap-&amp;gt;listSize) {
            Entry entry = &amp;amp;iterator-&amp;gt;hashMap-&amp;gt;list[iterator-&amp;gt;hashCode];
            if (entry-&amp;gt;key != NULL) {
                iterator-&amp;gt;count++;
                iterator-&amp;gt;entry = entry;
                break;
            }
        }
    }
    return iterator;
}

void freeHashMapIterator(HashMapIterator * iterator) {
    free(*iterator);
    *iterator = NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-使用测试&#34;&gt;8. 使用测试&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define Put(map, key, value) map-&amp;gt;put(map, (void *)key, (void *)value);
#define Get(map, key) (char *)map-&amp;gt;get(map, (void *)key)
#define Remove(map, key) map-&amp;gt;remove(map, (void *)key)
#define Existe(map, key) map-&amp;gt;exists(map, (void *)key)

int main() {

    HashMap map = createHashMap(NULL, NULL);
    Put(map, &amp;quot;asdfasdf&amp;quot;, &amp;quot;asdfasdfds&amp;quot;);
    Put(map, &amp;quot;sasdasd&amp;quot;, &amp;quot;asdfasdfds&amp;quot;);
    Put(map, &amp;quot;asdhfgh&amp;quot;, &amp;quot;asdfasdfds&amp;quot;);
    Put(map, &amp;quot;4545&amp;quot;, &amp;quot;asdfasdfds&amp;quot;);
    Put(map, &amp;quot;asdfaasdasdsdf&amp;quot;, &amp;quot;asdfasdfds&amp;quot;);
    Put(map, &amp;quot;asdasg&amp;quot;, &amp;quot;asdfasdfds&amp;quot;);
    Put(map, &amp;quot;qweqeqwe&amp;quot;, &amp;quot;asdfasdfds&amp;quot;);

    printf(&amp;quot;key: 4545, exists: %s\n&amp;quot;, Existe(map, &amp;quot;4545&amp;quot;) ? &amp;quot;true&amp;quot; : &amp;quot;false&amp;quot;);
    printf(&amp;quot;4545: %s\n&amp;quot;, Get(map, &amp;quot;4545&amp;quot;));
    printf(&amp;quot;remove 4545 %s\n&amp;quot;, Remove(map, &amp;quot;4545&amp;quot;) ? &amp;quot;true&amp;quot; : &amp;quot;false&amp;quot;);
    printf(&amp;quot;remove 4545 %s\n&amp;quot;, Remove(map, &amp;quot;4545&amp;quot;) ? &amp;quot;true&amp;quot; : &amp;quot;false&amp;quot;);
    printf(&amp;quot;key: 4545, exists: %s\n&amp;quot;, Existe(map, &amp;quot;4545&amp;quot;) ? &amp;quot;true&amp;quot; : &amp;quot;false&amp;quot;);

    HashMapIterator iterator = createHashMapIterator(map);
    while (hasNextHashMapIterator(iterator)) {
        iterator = nextHashMapIterator(iterator);
        printf(&amp;quot;{ key: %s, value: %s, hashcode: %d }\n&amp;quot;,
            (char *)iterator-&amp;gt;entry-&amp;gt;key, (char *)iterator-&amp;gt;entry-&amp;gt;value, iterator-&amp;gt;hashCode);
    }
    map-&amp;gt;clear(map);
    freeHashMapIterator(&amp;amp;iterator);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;key: 4545, exists: true
4545: asdfasdfds
remove 4545 true
remove 4545 false
key: 4545, exists: false
{ key: asdfasdf, value: asdfasdfds, hashcode: 2 }
{ key: asdhfgh, value: asdfasdfds, hashcode: 2 }
{ key: sasdasd, value: asdfasdfds, hashcode: 2 }
{ key: asdfaasdasdsdf, value: asdfasdfds, hashcode: 6 }
{ key: asdasg, value: asdfasdfds, hashcode: 7 }
{ key: qweqeqwe, value: asdfasdfds, hashcode: 9 }
&lt;/code&gt;&lt;/pre&gt;
        
      </description>
    </item>
    
  </channel>
</rss>
